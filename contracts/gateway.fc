#pragma version >=0.4.0;

#include "imports/stdlib.fc";
#include "common/errors.fc";
#include "common/state.fc";
#include "common/messages.fc";
#include "common/crypto.fc";

;; Sizes ===========================================
const size::op_code_size = 32;
const size::query_id_size = 64;
const size::memo_min = 20 * 8;
const size::signature_size = 65 * 8;
const size::hash_size = 32 * 8;

;; OP CODES ========================================
const op::internal::deposit = 100;
const op::internal::donate = 101;

const op::external::withdraw = 200;
const op::external::set_deposits_enabled = 201;

;; GAS FEE =========================================
;; Let's use const for now and refine this later
const deposit_gas_fee = 10000000; ;; 0.01 TON

;; PARSING =========================================

;; parses the query from the message body
;; https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#internal-message-body
(int, int) parse_intent(slice message_body) impure inline {
    int op = message_body~load_uint(size::op_code_size);
    int query_id = message_body~load_uint(size::query_id_size);

    return (op, query_id);
}

;; parses full message and returns (int flags, slice sender, slice rest_of_the_message)
;;
;; TL-B
;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
;;   src:MsgAddress dest:MsgAddressInt
;;   value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
;;   created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
(int, slice, slice) parse_flags_and_sender(cell full_message) inline {
    slice cs = full_message.begin_parse();

    int flags = cs~load_uint(4);
    slice sender = cs~load_msg_addr();

    return (flags, sender, cs);
}

;; INTERNAL MESSAGES ===============================

;; deposit TON to the gateway
() handle_deposit(slice sender, int amount, cell memo_cell) impure inline {
    ;; Validate memo
    slice memo = memo_cell.begin_parse();

    ;; EVM address is 20 bytes, so the memo should be at least 20 bytes long
    throw_if(error::memo_is_too_short, memo.slice_bits() < size::memo_min);
    ;; todo check if memo is too long. We don't want to have DDOS due to long memos (gas > 0.01 TON)

    ;; Update state
    var deposit_amount = amount - deposit_gas_fee;

    state::total_locked += deposit_amount;
    state::fees += deposit_gas_fee;

    ;; Update the state
    mutate_state();

    ;; Logs `$sender deposited $deposit_amount TON with $memo`
    cell log = begin_cell()
        .store_uint(op::internal::deposit, size::op_code_size)
        .store_uint(0, size::query_id_size)
        .store_slice(sender)
        .store_coins(deposit_amount)
        .store_ref(memo_cell)
        .end_cell();

    send_log_message(log);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    (int flags, slice sender, _) = in_msg_full.parse_flags_and_sender();

    ;; Check if the message is bouncable and fail
    ;; todo bouncED or bouncABLE?
    throw_if(error::bouncable, flags & 1);

    ;; We only want to support the basechain (id=0)
    (int wc, _) = sender.parse_std_addr();
    throw_unless(error::wrong_workchain, wc == 0);

    ;; Make sure the message contains op_code and query_id
    ;;
    ;; We DON't support op==0 aka "simple transfer with comment"
    ;; to prevent assets loss in case of a mistake tx by the user.
    throw_if(error::no_intent, in_msg_body.slice_bits() < (size::op_code_size + size::query_id_size));

    ;; query_id is not used for now.
    (int op, _) = in_msg_body.parse_intent();

    load_state();

    ;; Just accept the incoming value
    if (op == op::internal::donate) {
        throw_if(error::insufficient_value, msg_value < deposit_gas_fee);

        return ();
    }

    if (op == op::internal::deposit) {
        throw_if(error::deposits_disabled, state::deposits_enabled == 0);
        throw_if(error::insufficient_value, msg_value < deposit_gas_fee);

        ;; expect a ref with a memo
        throw_unless(error::memo_is_empty, in_msg_body.slice_refs());

        cell memo = in_msg_body~load_ref();

        return handle_deposit(sender, msg_value, memo);
    }

    throw(error::unknown_op);
}

;; EXTERNAL MESSAGES ===============================

(cell) authenticate_external_message(slice message) impure inline {
    ;; 1: Parse external message
    slice signature = message~load_bits(size::signature_size);
    int hash = message~load_uint(size::hash_size);
    cell payload = message~load_ref();

    ;; 2: Check hash validity
    throw_if(error::hash_mismatch, cell_hash(payload) != hash);

    ;; 3: Check signature
    int sig_check = check_ecdsa_signature(hash, signature, state::tss_address);

    ~strdump("check_ecdsa_signature");
    sig_check~dump();

    throw_if(error::invalid_signature, sig_check != true);

    return payload;
}

;; handle_withdrawal (recipient, amount, seqno)
() handle_withdrawal(slice message) impure inline {
    load_state();

    ;; Authenticate the message
    slice payload = authenticate_external_message(message).begin_parse();

    ;; Parse the payload
    slice recipient = payload~load_msg_addr();
    int amount = payload~load_coins();
    int seqno = payload~load_uint(size::seqno);

    (int wc, int recipient_addr) = recipient.parse_std_addr();
    throw_unless(error::wrong_workchain, wc == 0);

    throw_if(error::insufficient_value, amount == 0);
    throw_if(error::invalid_seqno, seqno != (state::seqno + 1));

    ;; Accept the message, the contract agrees to pay gas fees
    accept_message();

    ;; Sent TON and mutate the state
    int send_mode = message::mode::ordinary + message::flag::pay_fees_separately;
    send_simple_message(recipient_addr, amount, begin_cell().end_cell(), send_mode);

    state::total_locked -= amount;
    state::seqno += 1;

    mutate_state();
}

;; handle_enable_deposits (enabled, seqno)
() handle_enable_deposits(slice message) impure inline {
    load_state();

    slice payload = authenticate_external_message(message).begin_parse();

    int enabled = payload~load_uint(1);
    int seqno = payload~load_uint(size::seqno);

    throw_if(error::invalid_seqno, seqno != (state::seqno + 1));

    accept_message();

    ;; noop
    if (enabled == state::deposits_enabled) {
        return ();
    }

    state::deposits_enabled = enabled;
    state::seqno += 1;

    mutate_state();
}

;; Input for all external messages
() recv_external(slice message) impure {
    int op = message~load_uint(size::op_code_size);

    if (op == op::external::withdraw) {
        return handle_withdrawal(message);
    }

    if (op == op::external::set_deposits_enabled) {
        return handle_enable_deposits(message);
    }

    throw(error::unknown_op);
}

;; GETTERS ========================================

;; returns (int1 `deposits enabled`, int128 `total TON locked`, slice[20] `TSS address`)
(int, int, slice) query_state() method_id {
    load_state();

    return (state::deposits_enabled, state::total_locked, state::tss_address);
}

;; get nonce (int32)
int seqno() method_id {
    load_state();

    return state::seqno;
}
